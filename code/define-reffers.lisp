(in-package #:sb-simd-internals)

;;; In this file, we define reffers for scalars that can be defined in
;;; terms of built-in Common Lisp functions.
(macrolet
    ((define-reffer (reffer-record-name)
       (with-accessors ((value-record reffer-record-value-record)
                        (aref reffer-record-aref)
                        (row-major-aref reffer-record-row-major-aref))
           (find-function-record reffer-record-name)
         (let ((type (value-record-name value-record)))
           `(progn
              (define-inline ,row-major-aref (array index)
                (declare (type (array ,type) array))
                (row-major-aref array index))
              (define-inline (setf ,row-major-aref) (value array index)
                (declare (type ,type value)
                         (type (array ,type) array))
                (setf (row-major-aref array index) value))
              (defun ,aref (array &rest subscripts)
                (declare (type (array ,type) array))
                (apply #'aref array subscripts))
              (defun (setf ,aref) (value array &rest subscripts)
                (declare (type ,type value)
                         (type (array ,type) array))
                (setf (apply #'aref array subscripts) value))
              (define-compiler-macro ,aref (array &rest subscripts)
                `(aref (the (array ,',type) ,array) ,@subscripts))
              (define-compiler-macro (setf ,aref) (value array &rest subscripts)
                (let ((v (gensym "VALUE")))
                  `(let ((,v ,value))
                     (setf (aref (the (array ,',type) ,array) ,@subscripts)
                           ,v))))))))
     (define-reffers ()
       `(progn
          ,@(loop for reffer-record in (filter-function-records #'reffer-record-p)
                  collect `(define-reffer ,(reffer-record-name reffer-record))))))
  (define-reffers))
