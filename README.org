#+TITLE: sb-simd

This library provides a convenient SIMD interface for SBCL.  We provide a
SIMD wrapper for each Common Lisp function that operates on numbers.

* Types
The elements of a SIMD pack must be signed integers, unsigned integers, or
floating point numbers.  The corresponding element type specifiers start
with the prefix =s=, =u=, or =f=, respectively, followed by the number of
bits of that element.  For example, a 32bit floating point numbers would be
of type =f32=.  Other typical SIMD element type specifiers are =f64=, =u32=
and =u64=.

The type of a SIMD pack is the name of its element type, followed by a dot,
followed by its width.  A four element pack of 64bit floating point numbers
would therefore be called =f64.4=.  Other common SIMD type specifiers are
=f32.4=, =f32.8=, =u64.2= and =u64.4=.

The exact set of supported scalar and SIMD types depends on the platform.
A modern x86_64 machine might support up to 256 bit SIMD types, or even 512
bit SIMD types, while the CPU of a router might not support SIMD types at
all.

* The sb-simd Dictionary
The following sections list all functions provided by this library.  For
brevity, instructions that differ only in the type they operate on are
grouped together, where SIMD types are abbreviated as P, and SIMD element
types are abbreviated as E.

** /Function/ simd-width
Returns the width of a supplied SIMD type specifier.

*Examples:*
#+BEGIN_SRC lisp
(simd-width 'f64.2) => 2
(simd-width 'f32.8) => 8
#+END_SRC

** /Function/ simd-element-type
Returns the element type of a supplied SIMD type specifier.

*Examples:*
#+BEGIN_SRC lisp
=(simd-element-type 'f64.2) => f64
=(simd-element-type 'f32.8) => f32
#+END_SRC

** /Function/ E
Returns a scalar of type E.  Equivalent to =(lambda (x) (coerce x 'E))=.

*Examples:*
#+BEGIN_SRC lisp
(f32 5) => 5f0
(f64 5) => 5d0
#+END_SRC

** /Function/ P
Expects =(simd-width 'P)= arguments that can be coerced to
=(simd-element-type 'P)=.  Returns a SIMD pack of type P.

*Examples:*
#+BEGIN_SRC lisp
(f64.2 1 2.0) => \#<simd-pack 1d0 2d0>
#+END_SRC

** /Function/ P-values
Returns the elements of the supplied SIMD pack as multiple values.

*Examples:*
#+BEGIN_SRC lisp
(f64.2-values (f64.2 42 24)) => 42d0, 24d0
#+END_SRC

** /Accessor/ P-ref
Returns a SIMD pack containing =(simd-width 'P)= consecutive elements.

*Examples:*
#+BEGIN_SRC lisp
(defvar A (make-array '(2 2) :element-type 'u64 :initial-contents '((1 2) (3 4))))
(u64.2-ref A 0 0) => \#<simd-pack 1 2>
(u64.2-ref A 1 0) => \#<simd-pack 3 4>
(setf (u64.2-ref A 1 0) (u64.2 7 7)) => \#<simd-pack 0 0>
(aref A 1 1) => 7
#+END_SRC

** /Function/ P+, P*, P-sin, P-abs, ...
The SIMD equivalent of a standard Common Lisp function.

*Examples:*
#+BEGIN_SRC lisp
(f64.2+) => \#<simd-pack 0d0 0d0>
(f64.2+ (f64.2 1 2) 3 4) => \#<simd-pack 8d0 9d0>
(f64.2-sin 0) => \#<simd-pack 0d0 0d0>
#+END_SRC

* Examples
** Vector Sum
#+BEGIN_SRC lisp
(defun vsum (vector)
  (declare (type (simple-array f64 (*)) src))
  (let ((acc1 (f64.4 0 0 0 0))
        (acc2 (f64 0d0)))
    (declare (type f64.4 acc1)
             (type f64 acc2))
    (multiple-value-bind (quotient remainder)
        (floor (length src) 4)
      (dotimes (index quotient)
        (setf acc1 (f64.4-+ acc1 (f64.4-ref src (* 4 index)))))
      (dotimes (index remainder)
        (incf acc2 (f64-ref src (+ (* 4 quotient) index))))
      (multiple-value-call #'+ (f64.4-values acc1) acc2))))
#+END_SRC
