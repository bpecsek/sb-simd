#+TITLE: sb-simd

This library provides a convenient SIMD interface for SBCL.  We provide a
SIMD wrapper for each Common Lisp function that operates on numbers.

* Types
The elements of a SIMD pack must be signed integers, unsigned integers, or
floating point numbers.  The corresponding element type specifiers start
with the prefix =s=, =u=, or =f=, respectively, followed by the number of
bits of that element.  For example, a 32bit floating point numbers would be
of type =f32=.  Other typical SIMD element type specifiers are =f64=, =u32=
and =u64=.

The type of a SIMD pack is the name of its element type, followed by a dot,
followed by its width.  A four element pack of 64bit floating point numbers
would therefore be called =f64.4=.  Other common SIMD type specifiers are
=f32.4=, =f32.8=, =u64.2= and =u64.4=.

The exact set of supported scalar and SIMD types depends on the platform.
A modern x86_64 machine might support up to 256 bit SIMD types, or even 512
bit SIMD types, while the CPU of a router might not support SIMD types at
all.

* The sb-simd Dictionary
The following sections list all functions provided by this library.  For
brevity, instructions that differ only in the type they operate on are
grouped together, where SIMD types are abbreviated as P, and SIMD element
types are abbreviated as E.

** /Function/ simd-width
Returns the width of a supplied SIMD type specifier.

*Examples:*
#+BEGIN_SRC lisp
(simd-width 'f64.2) => 2
(simd-width 'f32.8) => 8
#+END_SRC

** /Function/ simd-element-type
Returns the element type of a supplied SIMD type specifier.

*Examples:*
#+BEGIN_SRC lisp
(simd-element-type 'f64.2) => f64
(simd-element-type 'f32.8) => f32
#+END_SRC

** /Function/ E
Returns a scalar of type E.  Equivalent to =(lambda (x) (coerce x 'E))=.

*Examples:*
#+BEGIN_SRC lisp
(f32 5) => 5f0
(f64 5) => 5d0
#+END_SRC

** /Function/ P
Expects =(simd-width 'P)= arguments.  It must be possible to coerce each of
these arguments to =(simd-element-type 'P)=.  Returns a SIMD pack of type
P.

*Examples:*
#+BEGIN_SRC lisp
(f64.2 1 2.0) => \#<simd-pack 1d0 2d0>
#+END_SRC

** /Function/ P-values
Returns =(simd-width 'P)= values that are the elements of the supplied SIMD
pack.

*Examples:*
#+BEGIN_SRC lisp
(f64.2-values (f64.2 42 24)) => 42d0, 24d0
(f32.8-values (f32.8 1 2 3 4 5 6 7 8)) => 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0
#+END_SRC

** /Accessor/ P-ref
Takes an array whose last dimension must have at least =(simd-width 'P)=
entries, followed by one or more array indices.  Returns a SIMD pack
containing =(simd-width 'P)= consecutive elements.

*Examples:*
#+BEGIN_SRC lisp
(defvar A (make-array '(2 2) :element-type 'u64 :initial-contents '((1 2) (3 4))))
(u64.2-ref A 0 0) => \#<simd-pack 1 2>
(u64.2-ref A 1 0) => \#<simd-pack 3 4>
(setf (u64.2-ref A 1 0) (u64.2 7 7)) => \#<simd-pack 0 0>
(aref A 1 1) => 7
A => \#2a((1 2) (7 7))
#+END_SRC

** /Function/ P-prefetch
Similar to =P-ref=, but does not produce a value.  The purpose of this
function is to prefetch the array data at the specified location, such that
a consecutive call to =P-ref= might be sped up.

** /Function/ P-if
This function takes exactly three arguments - a mask, and two SIMD packs of
type P.  It returns a SIMD pack of type P that is obtained by choosing
values from either the second or the third argument, depending on the mask.

** /Function/ P<=, P>=, P<, P<, P=, P!=
These SIMD comparison functions differ from their Common Lisp counterparts
in that they do not return a SIMD pack of booleans, but a mask suitable for
P-if.

** /Function/ P+, P*, P-sin, P-abs, ...
These functions are more or less identical to the ones from the Common Lisp
standard, except that they have been generalized to work with SIMD packs
instead of scalars.

The only notable differences of these SIMD functions is that they do not
support bignums.  Instead, integers will overflow in a hardware dependent
way.

*Examples:*
#+BEGIN_SRC lisp
(f64.2+) => \#<simd-pack 0d0 0d0>
(f64.2+ (f64.2 1 2) (f64.2 3 3) (f64.2 4 4)) => \#<simd-pack 8d0 9d0>
(f64.2-sin 0) => \#<simd-pack 0d0 0d0>
#+END_SRC

* Examples
** Vector Sum
#+BEGIN_SRC lisp
(defun vsum (vector)
  (declare (type (simple-array f64 (*)) src))
  (let ((acc1 (f64.4 0 0 0 0))
        (acc2 (f64 0d0)))
    (declare (type f64.4 acc1)
             (type f64 acc2))
    (multiple-value-bind (quotient remainder)
        (floor (length src) 4)
      (dotimes (index quotient)
        (setf acc1 (f64.4-+ acc1 (f64.4-ref src (* 4 index)))))
      (dotimes (index remainder)
        (incf acc2 (f64-ref src (+ (* 4 quotient) index))))
      (multiple-value-call #'+ (f64.4-values acc1) acc2))))
#+END_SRC
